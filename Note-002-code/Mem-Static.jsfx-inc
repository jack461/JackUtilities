/*
   A Static Memory allocation


    A block has the following structure :

        [  type  ]
        [  size  ]
  --->  [  ....  ]     address of the block, and its first element
           ....
        [  ....  ]     last element of the block
        [  size  ]
        [ ~ type ]     actually: type ~ 0x7FFFFFFF;


   MemInit();
       // initialize memory management
   MemInit(x);
       // initialize, starting allocation at address "x"
	
   MemAlloc(size, type, flags);
       // allocate a block of size "size" words,
       // with type "type" (use: 'data', 'blok', etc.)
       // and flags "flags" -- a sum of :
          MemFlClear = 1; // clear block contents once allocated
          MemFlAlign = 2; // allocate inside a 64k boundary
          MemFlCheck = 4; // check memory before allocation
          MemFlSigErr= 8; // stop process in case of error found

   MemCheck(); // verify the memory

   malloc(size); // classical malloc

*/

@init

function MemInit(start)
(
    MemStart = 0|max(0, start); // where to start from
    MemLow =  0x7FDA04C1; // Low memory marker
    MemHigh = 0x7FAD03C2; // high memory marker
    MemKey_min = 0x21212121; // The minim. key for a memory object
    MemKey_max = 0x7E7E7E7E; // the max. key for a memory object.
    MemZone = 0x7FFF0000; // get the zone ID of a mem address
    MemLoc = 0xFFFF; // location inside a zone
    MemMaxRq = 0x7FFFF; // max. request for an malloc
    MemFree = MemStart + 1; // The allocation pointer
    MemBlockSize = -1;
    MemBlockType = -2;
    MemFree[-1] = MemLow;
    MemFree[0] = MemHigh;
    MemFlClear = 1; // clear block contents once allocated
    MemFlAlign = 2; // allocate inside a 64k boundary
    MemFlCheck = 4; // check memory before allocation
    MemFlSigErr= 8; // stop process in case of error found
    MemFlFill = 16; // fill new block with random garbage
    MemGlobFlgs = 0;  // global flags
    MemErr = 0;
    MemErrLoc = 0;
);

function MemCheck(par)
local (pt, t, s)
(
    (MemErr == 0) ? (
        (par == 0) ? (
            pt = MemStart;
            (pt[0] != MemLow) ? (
                MemErr = 101; // low terminal missing
                MemErrLoc = pt;
            ) : (
                pt += 1;
                (pt[0] == MemHigh) ? pt = 0;
            );
    
            while ((MemErr == 0) && (pt > 0)) (
                t = pt[0];
                ((t < MemKey_min) || (t > MemKey_max)) ? (
                    MemErr = 110; // invalid type
                    MemErrLoc = pt+2;
                ) :
                (((s = pt[1]) < 0) || (s > MemMaxRq)) ? (
                    MemErr = 112; // invalid length
                    MemErrLoc = pt+2;
                ) :
                (s != pt[s+2]) ? (
                    MemErr = 113; // non matching length
                    MemErrLoc = pt+2;
                ) :
                (t != (pt[s+3] ~ 0x7FFFFFFF)) ? (
                    MemErr = 114; // non matching type
                    MemErrLoc = pt+2;
                ) : (
                    pt = pt + s + 4;
                    (pt[0] == MemHigh) ? pt = 0;
                );
            );
        ) : (
            pt = par - 2;
            t = pt[0];
            ((t < MemKey_min) || (t > MemKey_max)) ? (
                MemErr = 110; // invalid type
                MemErrLoc = pt+2;
            ) :
            (((s = pt[1]) < 0) || (s > MemMaxRq)) ? (
                MemErr = 112; // invalid length
                MemErrLoc = pt+2;
            ) :
            (s != pt[s+2]) ? (
                MemErr = 113; // non matching length
                MemErrLoc = pt+2;
            ) :
            (t != (pt[s+3] ~ 0x7FFFFFFF)) ? (
                MemErr = 114; // non matching type
                MemErrLoc = pt+2;
            ) : (
                pt = pt + s + 4;
                (pt[0] == MemHigh) ? pt = 0;
            );
        );
    );
    MemErr;
);

function MemAlloc(size, type, flags)
local (add, fill)
(
    flags |= MemGlobFlgs; // merge with global flags
    (flags & MemFlCheck) ? (
        MemCheck();
    );
    ((flags & MemFlSigErr) && (MemErr != 0)) ? (
        add = 0;
    );
    size = 0|min(MemMaxRq, max(0, size));
    type = 0|min(MemKey_max, max(MemKey_min, type));
    flags = 0|flags;
    add = MemFree + 2;
    // Should the block be limited to a 64k zone ?
    ((flags & MemFlAlign) && ((add & MemZone) != ((add + size - 1) & MemZone))) ? (
        // create a filler block of the appropriate size
        fill = 0x10000 - (MemFree & MemLoc) - 6; 
        add[-2] = 'fill';
        add[-1] = fill;
        MemFree = add + fill + 2;
        MemFree[-2] = fill;
        MemFree[-1] = 'fill' ~ 0x7FFFFFFF;
        add = MemFree + 2;
    );
    add[-2] = type;
    add[-1] = size;
    MemFree = add + size + 2;
    MemFree[-2] = size;
    MemFree[-1] = type ~ 0x7FFFFFFF;
    MemFree[0] = MemHigh;
    (flags & MemFlFill) ? memcpy(add, 0|rand(MemFree), size);
    (flags & MemFlClear) ? memset(add, 0, size);
    add;
);

function malloc(size) ( MemAlloc(size, 'data', 0); );


